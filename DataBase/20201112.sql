--202011.12

--ddl
--테이블생성 : create table table_name(
--                      column_name domain [constraint],   
--                      column_name domain [constraint],
--                      column_name domain [constraint]
--)

CREATE TABLE test_tbl ( no NUMBER(4),user_name VARCHAR2(10),user_id VARCHAR2(16),user_password VARCHAR2(12),reg_date TIMESTAMP DEFAULT SYSDATE );

desc test_tbl;
DESC EMP;

CREATE TABLE EMP01(ENPNO VARCHAR(4),ENAME VARCHAR(10),SAL NUMBER(7,2));
DESC emp01;

--CREATE TABLE ~AS~:테이블 복사
-- CREATE TABLE 명령어 다음에 컬럼을 일일이 정의하는 대신 AS 절을추가하여 EMP 테이블과 동일한 내용과 구조를 갖는 EMP02 테이블을생성해 봅시다.
CREATE TABLE EMP02 AS SELECT*FROM EMP;

DESC EMP02; -- 다만 제약 조건은 가져오지 못 한다.
--SELECT  서브쿼리문의 SELECT 절에 *대신 컬럼명을 명시하면 기존테이블에서 일부의 컬럼만 복사 할 수 있다.
CREATE TABLE EMP03 AS SELECT EMPNO,ENAME,SAL FROM EMP;

SELECT * FROM emp03;

--서브 쿼리문의 SELECT 문을 구성할 때 WHERE 절을 추가하여 원하는조건을 제시하면 기존 테이블에서 일부의 행만 복사합니다.
CREATE TABLE EMP04 AS SELECT * FROM EMP WHERE DEPTNO=10;

SELECT * FROM emp04;

--테이블의 구조만 복사하는 것은 별도의 명령이 있는 것이 아닙니다. 이
--역시 서브 쿼리를 이용해야 하는데 WHERE 조건 절에 항상 거짓이 되는
--조건을 지정하게 되면 테이블에서 얻어질 수 있는 로우가 없게 되므로 빈
--테이블이 생성되게 됩니다.
CREATE TABLE EMP05  AS SELECT * FROM EMP WHERE 1=0;

SELECT * FROM EMP05;

--테이블의 삭제: 저장공간을 삭제-> 저장되어 있는 데이터도 모두 삭제
--DROP TABLE TABLE_NAME

DROP TABLE tEST_TBL;

--TRUNCATE : 테이블의 모든 명령 행을 바로 삭제 물리적인 적용도 바로 진행 DELECT

CREATE TABLE EMP06 AS SELECT * FROM EMP;

SELECT * FROM EMP06;

TRUNCATE TABLE EMP06;


--RENAME 현재 테이블이름 TO 새로운 이름

RENAME EMP06 TO NEW_EMP;
SELECT * FROM TAB;

RENAME NEW_EMP TO HOT_EMP;
SELECT * FROM TAB;


--테이블 구조의 변경 
--ALTER TABLE TABLE_NAME {ADD(컬럼의 추가)|MODIFY(컬럼의 수정 )|DROP(컬럼의 삭제)}

--기존 테이블의 속성 추가: 행당 기본데이터는 NULL 값으로 추가 된다.
--EMP01 JOB 커럼은 추 JOB VERCHER2(10)
DESC EMP01;
ALTER TABLE EMP01 ADD(DEPTNO NUMBER(2));
ALTER TABLE EMP01 ADD(DEPTNO NUMBER(2));

-- 기본 테이블의 컬럼 변경 : 새롭게 정의된 컬럼을 교체하는것 

ALTER TABLE EMP01 MODIFY(DEPTNO NUMBER(10));

--기본 테이블의 컬럼 삭제 : 데이터도 모두 삭제
ALTER TABLE EMP01 DROP (DEPTNO);


--제약 조건 정의 
INSERT INTO DEPT VALUES(10,'TEST',SEOUL);

DESC RMP01;
INSERT INTO EMP01 VALUES(NULL.NULL,1000,'TESTER');
SELECT * FROM EMP01;


--EMP01 테이블 삭제
DROP TABLE EMP01;
--EMP01테이블 생성: EMP01테이블에 NULL 값이 들어 가지 않도록 
CREATE TABLE EMP01(     EMPNO NUMBER(2), 
                        ENAME VARCHAR2(10) NOT NULL,
                        JOB VARCHAR(9) ,
                        DEPTNO NUMBER(2) NOT NULL
                        );

INSERT INTO EMP01 VALUES( NULL, NULL,'TESTER',1000);


--데이터의 중복 금지:UNIQUE
DROP TABLE EMP02;
CREATE TABLE  EMP02( 

                        EMPNO NUMBER(4) UNIQUE,
                        ENAME VARCHAR2(10) NOT NULL,
                        JOB VARCHAR(9) ,
                        DEPTNO NUMBER(2) NOT NULL 
                        );
                        
                        DESC EMP02;
                        SELECT
                            *
                        FROM EMP02;
INSERT INTO EMP02 VALUES(1,TEST2 )                        


--EMPNO NOT NULL, UNIQUE 제약을 동시에 적용
DROP TABLE EMP03;
CREATE TABLE EMP03(
EMPNO NUMBER(4) NOT NULL UNIQUE,
ENAME VERCHAR2(10) NOT NULL
);
INSERT INTO EMP03 VALUES (NULL,'TEST1');
INSERT INTO EMP03 VALUES (1,NULL);
INSERT INTO EMP03 VALUES (1,'TEST11');
INSERT INTO EMP03 VALUES (1,'TEST12');
INSERT INTO EMP03 VALUES (2,'TEST12');
SELECT * FROM TAB;
SELECT * FROM EMP03;
DROP TABLE EMP04;
CREATE TABLE EMP04(
EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10) NOT NULL
);
INSERT INTO EMP04 VALUES (NULL,'TEST1');
INSERT INTO EMP04 VALUES (1,NULL);
INSERT INTO EMP04 VALUES (1,'TEST11');
INSERT INTO EMP04VALUES (1,'TEST12');
INSERT INTO EMP04 VALUES (2,'TEST12');
SELECT * FROM EMP04;


--외래키 제약 조건 : 참조하는 테이블 
DROP TABLE EMP05;
CREATE TABLE EMP05(
EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10) NOT NULL,
DEPTNO NUMBER(2) REFERENCES DEPT(DEPTNO)-- 외래키

);
SELECT * FROM EMP05;
INSERT INTO EMP05 VALUES (1,'TEST1',10);
INSERT INTO EMP05 VALUES (2,'TEST2',40);
INSERT INTO EMP05 VALUES (3,'TEST2',NULL);

--CHECK: 특정 범위 제한 

DROP TABLE EMP06;

CREATE TABLE EMP06(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    SAL NUMBER(7,2) CHECK (SAL>=800)

);

INSERT INTO EMP06 VALUES(1,'TEST',1000);
INSERT INTO EMP06 VALUES(2,'TEST',856);
INSERT INTO EMP06 VALUES(3,'TEST',100);

--DEFAULT: INSERT 사이에 데이터가 입력되지 않을때 자동으로 등록
DROP TABLE EMP07;
CREATE TABLE EMP07(
  EMPNO NUMBER(4) PRIMARY KEY,
  ENAME VARCHAR2(10) NOT NULL,
  SAL NUMBER(7,2) CHECK (SAL>=50),
  COMM NUMBER(7,2) DEFAULT 0,
  HIREDATE DATE DEFAULT SYSDATE
);

INSERT INTO EMP07(EMPNO,ENAME,SAL)
VALUES(1,'TEST',3000);

SELECT*FROM EMP07;

-- 제약 조건에 이름 부여 

DROP TABLE EMP08;
CREATE TABLE EMP08(
  EMPNO NUMBER(4) CONSTRAINT EMP08_EMPNO_PK PRIMARY KEY,
  ENAME VARCHAR2(10)  CONSTRAINT EMP08_ENAME_NN NOT NULL,
  SAL NUMBER(7,2) CONSTRAINT EMP08_SAL_CK CHECK (SAL>=50),
  COMM NUMBER(7,2) DEFAULT 0,
  HIREDATE DATE DEFAULT SYSDATE
);

INSERT INTO EMP08(EMPNO,ENAME,SAL) VALUES(1,'TEST',3000);

SELECT*FROM EMP09;

--테이블 레벨에서 제약 조건 정의

CREATE TABLE EMP09(
 EMPNO NUMBER(4),
 ENAME VARCHAR2(10) NOT NULL,
 JOB vARCHAR2(9),
DEPTNO NUMBER(10),
CONSTRAINT EMP09_EMPNO_PK PRIMARY KEY (EMPNO),
CONSTRAINT EMP09_JOB_UK UNIQUE(JOB),
CONSTRAINT EMP09_DEPTNO_FK FOREIGN KEY (DEPTNO) REFERENCES DEPT(DEPTNO)

);
INSERT INTO EMP09 VALUES(1,'TESTER','JOB1',40);
INSERT INTO EMP09 VALUES(2,'TESTER','JOB2',40);\\

--DML : 데이터의 삽입 수정 삭제
--DML의 대상은 행이다. 행단우 수저 ,행단위 삭제

--DATE삽입

--INSERT INTO TAXLE_NAME(ㅈ데이터 저장항 컬럼들)VEALES(저장될 칼럼);

-->DEPT01 테이블생성 

CREATE TABLE DEPT01 AS SELECT * FROM DEPT ;
INSERT INTO DEPT01(DEPTNO,DNAME ,LOC) VALUES (10,'마케팅','서울');
SELECT * FROM  DEPT01;

DESC DEPT01;
INSERT INTO DEPT01 VALUES(20,'마케팅','서울');

--NULL 값의 입력
INSERT INTO DEPT01  (DEPTNO,DNAME)VALUES(30,'QC');
INSERT INTO DEPT01 VALUES (NULL,30,'QC');

--서브 쿼리를 이용해서 데이터 입력
 DROP TABLE DEPT02 AS SELECT * FROM DEPT;
 

 
 --EPDLXJ TNWJD 
 --UPDATE TABLE_NAME SET CULUMN_NAME=VALUE,... WHERE 행을 찾기위한 조건 
 -- 모든 사원의 부서번호를 30번으로 수정ㅎ ㅐ; 
 
 DROP TABLE EMP10;
 
CREATE TABLE EMP10 AS SELECT * FROM EMP;

UPDATE EMP10 SET DEPTNO=30;

SELECT
    *
FROM EMP10;

--. 이번엔 모든 사원의 급여를 10% 인상시키는 UPDATE 문을 보겠습니다
UPDATE EMP10
SET SAL=SAL*1.1;

--급여가 3000 이상인 사원만 
--급여를 10% 인상합니다,
-UPDATE  EMP10 SET SAL=>3000 AND SAL/10;

--모든 사원의 입사일을 오늘로 수정하려면 다음과 같이 합니다
-UPDATE  EMP10 SET HIREDATE = SYSDATE
--WHERE HIREDATE BETWEEN '1997/01/01'AND'1987/12/31'
WHERE SUBSTR(HIREDATE,1,2)='87'
;

SELECT * FROM EMP10 SHERE SUBSTR(HIREDATE,1,2)='87';
-- 전체데이터를 삭제 DDL

TRUNCATE TABLE EMP10;

INSERT INTO EP10;
--SCOTT 사원의 부서번호는 20번으로, 직급은 MANAGER로 한꺼번에수정하도록 합시다

UPDATE EMP10
SET DEPTNO=20,JOB='MANAGER'
WHERE ENAME='SCOTT';

--SCOTT 사원의 입사일자는 오늘로, 급여를 50 으로 커미션을 4000 으로

UPDATE EMP10
SET SAL=20,COMM=4000
WHERE ENAME ='SCOTT';

SELECT * FROM EMP10;

--20번 부서의 지역명을 40번 부서의 지역명으로 변경하기 위해서 서브쿼리문을 사용해 봅시다.
DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS 
SELECT*FROM DEPT;
UPDATE DEPT01 
SET LOC=(SELECT LOC FROM DEPT01 WHERE DEPTNO=40)
WHERE DEPTNO=20;

--부서 번호가 20번인 부서의 이름과 지역은 RESEARCH와
--DALLAS입니다. 다음은 부서번호가 20인 부서의 부서명과 지역명을 부서
--번호가 40번인 부서와 동일하게 변경하기 위한 UPDATE 명령문입니다.

UPDATE DEPT01
SET DNAME=(SELECT  DNAME FROM DEPT01 WHERE DEPTNO=40), LOC=(SELECT LOC FROM DEPT01 WHERE DEPTNO=40)
WHERE DEPTNO=20
;

UPDATE DEPT01
SET (DNAME,LOC)=(SELECT DNAME,LOCFROM FROM DEPT01 WHERE DEPTNO=40)
WHERE DEPTNO=20;

--테이블의 행 삭제 
--DELETE FROM TABLE_NAME : 행 단위 삭제, WHERE 가 없으면 전체 행이 대상 

--DEPT01 테이블의 ㅗㅁ든 데이터를 삭제

SELECT * FROM DEPT01;

DELETE FROM DEPT01;

--EMP10 테이블의 데이터중 부서번호가 10번 부서의 사원들을 삭제 
DELETE FROM EMP10 WHERE DEPTNO=10;


--사원 테이블에서 부서명이 SALES인 사원을 보두 삭제해봅시다.
DELETE FROM EMP10
WHERE DEPTNO=(

        SELECT DEPTNO FROM DEPT WHERE DNAME='SALES'
);